#!/usr/bin/env python

import os
import numpy as np
import matplotlib.pyplot as plt
import tqdm
import torch

from src.gp.GPyModelWrapper import GPyModelWrapper
from src.gp.gp_utils import *
from src.utils.DirectoryConfig import DirectoryConfig as DirConf
from src.gp.GPDataset import GPDataset
from src.utils.utils import state_features_to_idx, sensor_features_to_idx

def train_MPC_gp(quad_name, trajectory_name, env, gt, epoch, input_feature, output_feature, lrate=0.1, n_induce=None, verbose=0,keep_train_data=False, n_seeds=None):
    """
    Train GP models for MPC model compensation. The trained GP model provides acceleration corrections to the dynamic model for
    improved accuracy of model prediction. 
    The "Exact" model will be trained by training a "dense" model using higher 
    number of n_dense_points, and a "sparse" model with smaller n_sparse_points generated by this dense model. 
    The "Approx" model will be trained with n_dense_points 
    :param quad_name: Name of the quadrotor
    :type quad_name: string
    :param trajectory_name: The name of the trajectory that was executed to collect flight data
    :type trajectory_name: string
    :param env: String value indicating the environment the quadrotor flight was executed for data collection
    :type env: string
    :param gt: Boolean value to indicate whether groundtruth state measurements were used for flight execution.
    :type gt: Bool
    :param epoch: Number of training epochfor GP training
    :type epoch: Int
    :param n_dense_points: Integer value indicating number of points utilized for Exact Dense GP training
    :type n_dense_points: Int
    :param n_sparse_points: Integer value indicating number of points utilized for Exact Sparse GP training
    :type n_sparse_points: Int
    :param n_induce: Number of inducing points for Approx GP model types
    :type n_induce: Int
    """
    load_model = False

    x_features_idx = state_features_to_idx(input_feature)
    y_features_idx = state_features_to_idx(output_feature)

    if trajectory_name == "random":
        x_train = np.zeros((len(x_features_idx), 0))
        y_train = np.zeros((len(x_features_idx), 0))

        for i in range(n_seeds):
            # Load Dataset
            flight_name = "%s_mpc%s_%s"%(env, "_gt" if gt else "", quad_name)
            results_dir = os.path.join(DirConf.FLIGHT_DATA_DIR, flight_name, "%s_%d"%(trajectory_name, i))
            gp_ds = GPDataset(results_dir)

            # Select data points to be used
            x_train_ = np.zeros((len(x_features_idx), gp_ds.get_len()))
            y_train_ = np.zeros((len(x_features_idx), gp_ds.get_len()))
            for i, (xi, yi) in enumerate(zip(x_features_idx, y_features_idx)):
                train_in, train_out = gp_ds.get_train_ds(xi, yi)
                x_train_[i, :] = np.squeeze(train_in)
                y_train_[i, :] = np.squeeze(train_out)
            x_train = np.append(x_train, x_train_, axis=1)
            y_train = np.append(y_train, y_train_, axis=1)

    else:
        # Load Dataset
        flight_name = "%s_mpc%s_%s"%(env, "_gt" if gt else "", quad_name)
        results_dir = os.path.join(DirConf.FLIGHT_DATA_DIR, flight_name, trajectory_name)
        gp_ds = GPDataset(results_dir)

        # Select data points to be used
        x_train = np.zeros((len(x_features_idx), gp_ds.get_len()))
        y_train = np.zeros((len(x_features_idx), gp_ds.get_len()))
        for i, (xi, yi) in enumerate(zip(x_features_idx, y_features_idx)):
            train_in, train_out = gp_ds.get_train_ds(xi, yi)
            x_train[i, :] = np.squeeze(train_in)
            y_train[i, :] = np.squeeze(train_out)

    x_train = torch.Tensor(x_train.T)
    y_train = torch.Tensor(y_train.T)

    # Create GP Model
    model_name = "%s_%s_%s_%d_mpc"%("gz" if env == "gazebo" else "a", 
                                    input_feature,
                                    output_feature,  
                                    n_induce)
    gp_model = GPyModelWrapper(model_name, load=load_model, x_features=x_features_idx, y_features=y_features_idx, keep_train_data=keep_train_data)
    if not load_model:
        gp_model.train(x_train, y_train, epoch, induce_num=n_induce, verbose=verbose, script_model=False, lrate=lrate)

    # x, y = gp_ds.get_train_ds()
    # x = torch.Tensor(x[:, x_features_idx])
    # y = torch.Tensor(y[:, y_features_idx])
    gp_model.visualize_model(x_train, y_train)
            
    return gp_model

def train_MHE_gp(quad_name, trajectory_name, env, epoch, input_feature, output_feature, lrate=0.1, n_induce=None, verbose=0, keep_train_data=False, mhe_type="d", n_seeds=None):
    """
    Train GP models for D-MHE model compensation. The trained GP model provides acceleration corrections to the dynamic model for
    improved accuracy of model prediction. 
    The "Exact" model will be trained by training a "dense" model using higher 
    number of n_dense_points, and a "sparse" model with smaller n_sparse_points generated by this dense model. 
    The "Approx" model will be trained with n_dense_points 
    :param quad_name: Name of the quadrotor
    :type quad_name: string
    :param trajectory_name: The name of the trajectory that was executed to collect flight data
    :type trajectory_name: string
    :param env: String value indicating the environment the quadrotor flight was executed for data collection
    :type env: string
    :param epoch: Number of training epochfor GP training
    :type epoch: Int
    :param n_dense_points: Integer value indicating number of points utilized for Exact Dense GP training
    :type n_dense_points: Int
    :param n_sparse_points: Integer value indicating number of points utilized for Exact Sparse GP training
    :type n_sparse_points: Int
    :param n_induce: Number of inducing points for Approx GP model types
    :type n_induce: Int
    """
    load_model = False
    # TODO: input feature for measurements fix
    x_features_idx = sensor_features_to_idx(input_feature)
    y_features_idx = state_features_to_idx(output_feature)

    if trajectory_name == "random":
        x_train = np.zeros((len(x_features_idx), 0))
        y_train = np.zeros((len(x_features_idx), 0))

        for i in range(n_seeds):
            # Load Dataset
            flight_name = "%s_%smhe_%s"%(env, mhe_type, quad_name)
            results_dir = os.path.join(DirConf.FLIGHT_DATA_DIR, flight_name, "%s_%d"%(trajectory_name, i))

            # TODO: Change to FlightDataset
            gp_ds = GPDataset(results_dir)
            
            # Select data points to be used
            x_train_ = np.zeros((len(x_features_idx), gp_ds.get_len()))
            y_train_ = np.zeros((len(x_features_idx), gp_ds.get_len()))
            for i, (xi, yi) in enumerate(zip(x_features_idx, y_features_idx)):
                train_in, train_out = gp_ds.get_train_ds(xi, yi)
                x_train_[i, :] = np.squeeze(train_in)
                y_train_[i, :] = np.squeeze(train_out)
            x_train = np.append(x_train, x_train_, axis=1)
            y_train = np.append(y_train, y_train_, axis=1)
    else:
        # Load Dataset
        flight_name = "%s_%smhe_%s"%(env, mhe_type, quad_name)
        results_dir = os.path.join(DirConf.FLIGHT_DATA_DIR, flight_name, trajectory_name)
        # TODO: Change to FlightDataset
        gp_ds = GPDataset(results_dir)
        
        # Select data points to be used
        x_train = np.zeros((len(x_features_idx), gp_ds.get_len()))
        y_train = np.zeros((len(x_features_idx), gp_ds.get_len()))
        for i, (xi, yi) in enumerate(zip(x_features_idx, y_features_idx)):
            train_in, train_out = gp_ds.get_train_ds(xi, yi)
            x_train[i, :] = np.squeeze(train_in)
            y_train[i, :] = np.squeeze(train_out)

    x_train = torch.Tensor(x_train.T)
    y_train = torch.Tensor(y_train.T)

    # Create GP Model
    model_name = "%s_%s_%s_%d_mhe"%("gz" if env == "gazebo" else "rt", 
                                    input_feature,
                                    output_feature,  
                                    n_induce)
    gp_model = GPyModelWrapper(model_name, load=load_model, x_features=x_features_idx, y_features=y_features_idx, mhe=True, keep_train_data=keep_train_data)
    gp_model.train(x_train, y_train, epoch, induce_num=n_induce, verbose=verbose, script_model=False, lrate=lrate)

    # x, y = gp_ds.get_train_ds()
    # x = torch.Tensor(x[:, x_features_idx])
    # y = torch.Tensor(y[:, y_features_idx])
    gp_model.visualize_model(x_train, y_train,)

    return gp_model

if __name__ == "__main__":
    quad_name = "hummingbird"
    trajectory_name = "random"
    n_seeds = 5
    environment = "gazebo"  
    mhe_type = "d"
    gt = False
    mpc_input_feature = 'v'
    mhe_input_feature = 'a'
    output_feature = 'v'
    mpc_epoch = 1000
    mpc_lrate=0.01
    mhe_epoch = 1000
    mhe_lrate=0.005
    n_induce = 20
    verbose = 5
    keep_train_data = True
    train_mpc = True
    train_mhe = False
    if train_mpc:
        train_MPC_gp(quad_name, 
                    trajectory_name, 
                    environment, 
                    gt, 
                    mpc_epoch,  
                    mpc_input_feature,
                    output_feature,
                    n_induce=n_induce,
                    lrate=mpc_lrate,
                    verbose=verbose,
                    keep_train_data=keep_train_data,
                    n_seeds=n_seeds)
    if train_mhe:
        train_MHE_gp(quad_name,
                    trajectory_name,
                    environment,
                    mhe_epoch,
                    mhe_input_feature,
                    output_feature,
                    lrate=mhe_lrate,
                    n_induce=n_induce,
                    verbose=verbose,
                    keep_train_data=keep_train_data,
                    mhe_type=mhe_type,
                    n_seeds=n_seeds)
