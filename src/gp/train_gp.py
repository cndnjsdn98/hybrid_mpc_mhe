#!/usr/bin/env python

import os
import numpy as np
import matplotlib.pyplot as plt
import tqdm
import torch

from src.gp.GPyModelWrapper import GPyModelWrapper
from src.gp.gp_utils import *
from src.utils.DirectoryConfig import DirectoryConfig as DirConf
from src.gp.GPDataset import GPDataset
from src.utils.utils import state_features_to_idx, sensor_features_to_idx

def train_MPC_gp(quad_name, trajectory_name, env, gt, epoch, input_feature, output_feature, n_induce=None, verbose=0,keep_train_data=False):
    """
    Train GP models for MPC model compensation. The trained GP model provides acceleration corrections to the dynamic model for
    improved accuracy of model prediction. 
    The "Exact" model will be trained by training a "dense" model using higher 
    number of n_dense_points, and a "sparse" model with smaller n_sparse_points generated by this dense model. 
    The "Approx" model will be trained with n_dense_points 
    :param quad_name: Name of the quadrotor
    :type quad_name: string
    :param trajectory_name: The name of the trajectory that was executed to collect flight data
    :type trajectory_name: string
    :param env: String value indicating the environment the quadrotor flight was executed for data collection
    :type env: string
    :param gt: Boolean value to indicate whether groundtruth state measurements were used for flight execution.
    :type gt: Bool
    :param epoch: Number of training epochfor GP training
    :type epoch: Int
    :param n_dense_points: Integer value indicating number of points utilized for Exact Dense GP training
    :type n_dense_points: Int
    :param n_sparse_points: Integer value indicating number of points utilized for Exact Sparse GP training
    :type n_sparse_points: Int
    :param n_induce: Number of inducing points for Approx GP model types
    :type n_induce: Int
    """
    load_model = False

    # Load Dataset
    flight_name = "%s_mpc%s_%s"%(env, "_gt" if gt else "", quad_name)
    results_dir = os.path.join(DirConf.FLIGHT_DATA_DIR, flight_name, trajectory_name)
    x_features_idx = state_features_to_idx(input_feature)
    y_features_idx = state_features_to_idx(output_feature)
    gp_ds = GPDataset(results_dir)

    # Select data points to be used
    x_train = np.zeros((len(x_features_idx), gp_ds.get_len()))
    y_train = np.zeros((len(x_features_idx), gp_ds.get_len()))
    for i, (xi, yi) in enumerate(zip(x_features_idx, y_features_idx)):
        train_in, train_out = gp_ds.get_train_ds(xi, yi)
        x_train[i, :] = np.squeeze(train_in)
        y_train[i, :] = np.squeeze(train_out)
    x_train = torch.Tensor(x_train.T)
    y_train = torch.Tensor(y_train.T)

    # Create GP Model
    model_name = "%s_%s_%s_%d_mpc"%("gz" if env == "gazebo" else "a", 
                                    input_feature,
                                    output_feature,  
                                    n_induce)
    gp_model = GPyModelWrapper(model_name, load=load_model, x_features=x_features_idx, y_features=y_features_idx, keep_train_data=keep_train_data)
    if not load_model:
        gp_model.train(x_train, y_train, epoch, induce_num=n_induce, verbose=verbose, script_model=False)

    x, y = gp_ds.get_train_ds()
    x = torch.Tensor(x[:, x_features_idx])
    y = torch.Tensor(y[:, y_features_idx])
    gp_model.visualize_model(x, y)
            
    return gp_model

def train_MHE_gp(quad_name, trajectory_name, env, epoch, input_feature, output_feature, n_induce=None, verbose=0, keep_train_data=False):
    """
    Train GP models for D-MHE model compensation. The trained GP model provides acceleration corrections to the dynamic model for
    improved accuracy of model prediction. 
    The "Exact" model will be trained by training a "dense" model using higher 
    number of n_dense_points, and a "sparse" model with smaller n_sparse_points generated by this dense model. 
    The "Approx" model will be trained with n_dense_points 
    :param quad_name: Name of the quadrotor
    :type quad_name: string
    :param trajectory_name: The name of the trajectory that was executed to collect flight data
    :type trajectory_name: string
    :param env: String value indicating the environment the quadrotor flight was executed for data collection
    :type env: string
    :param epoch: Number of training epochfor GP training
    :type epoch: Int
    :param n_dense_points: Integer value indicating number of points utilized for Exact Dense GP training
    :type n_dense_points: Int
    :param n_sparse_points: Integer value indicating number of points utilized for Exact Sparse GP training
    :type n_sparse_points: Int
    :param n_induce: Number of inducing points for Approx GP model types
    :type n_induce: Int
    """
    load_model = False

    # Load Dataset
    flight_name = "%s_dmhe_%s"%(env, quad_name)
    results_dir = os.path.join(DirConf.FLIGHT_DATA_DIR, flight_name, trajectory_name)
    # TODO: input feature for measurements fix
    x_features_idx = sensor_features_to_idx(input_feature)
    y_features_idx = state_features_to_idx(output_feature)
    # TODO: Change to FlightDataset
    gp_ds = GPDataset(results_dir)
    
    # Select data points to be used
    x_train = np.zeros((len(x_features_idx), gp_ds.get_len()))
    y_train = np.zeros((len(x_features_idx), gp_ds.get_len()))
    for i, (xi, yi) in enumerate(zip(x_features_idx, y_features_idx)):
        train_in, train_out = gp_ds.get_train_ds(xi, yi)
        x_train[i, :] = np.squeeze(train_in)
        y_train[i, :] = np.squeeze(train_out)
    x_train = torch.Tensor(x_train.T)
    y_train = torch.Tensor(y_train.T)

    # Create GP Model
    model_name = "%s_%s_%s_%d_mhe"%("gz" if env == "gazebo" else "rt", 
                                    input_feature,
                                    output_feature,  
                                    n_induce)
    gp_model = GPyModelWrapper(model_name, load=load_model, x_features=x_features_idx, y_features=y_features_idx, mhe=True, keep_train_data=keep_train_data)
    gp_model.train(x_train, y_train, epoch, induce_num=n_induce, verbose=verbose, script_model=False)

    x, y = gp_ds.get_train_ds()
    x = torch.Tensor(x[:, x_features_idx])
    y = torch.Tensor(y[:, y_features_idx])
    gp_model.visualize_model(x, y,)

    return gp_model

if __name__ == "__main__":
    quad_name = "hummingbird"
    trajectory_name = "lemniscate"
    environment = "gazebo"
    gt = True
    mpc_input_feature = 'v'
    mhe_input_feature = 'a'
    output_feature = 'v'
    mpc_epoch = 1000
    mhe_epoch = 500
    n_induce = 20
    verbose = 1
    keep_train_data = True
    train_mpc = True
    train_mhe = True
    if train_mpc:
        train_MPC_gp(quad_name, 
                    trajectory_name, 
                    environment, 
                    gt, 
                    mpc_epoch,  
                    mpc_input_feature,
                    output_feature,
                    n_induce=n_induce,
                    verbose=verbose,
                    keep_train_data=keep_train_data)
    if train_mhe:
        train_MHE_gp(quad_name,
                    trajectory_name,
                    environment,
                    mhe_epoch,
                    mhe_input_feature,
                    output_feature,
                    n_induce=n_induce,
                    verbose=verbose,
                    keep_train_data=keep_train_data)
